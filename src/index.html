<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
    <meta charset="utf-8">
    <title>...</title>
<style media="screen">
html, body {
    padding: 1rem;
}
</style>
</head>
<body>


<div id="app">
    <div>
        <p>
            <label for="user-file-gpx">.gpx file</label>
            <br><input type="file" accept=".gpx" @change="loadGPX" id="user-file-gpx" />
        </p>
        <p>
            <label for="user-file-gpx">image</label>
            <br><input type="file" accept="image/*" id="user-file-image" />
        </p>
    </div>

    <hr>

    <ul>
        <li>Distance :  {{ gpx.distance.kmÂ }} (km)</li>
        <li>Duration : {{ gpx.duration.hours }}h{{ gpx.duration.minutes }}m{{ gpx.duration.seconds }}s</li>
        <li>Speed: {{ gpx.speed.kmh }} (km/h)</li>
        <li>Pace: {{ gpx.pace.perKm.minutes }}:{{ gpx.pace.perKm.seconds }} (min/Km)</li>
        <li>Elevation Gain: {{ gpx.elevation.gain }}m</li>
    </ul>
</div>



<script src="https://cdn.jsdelivr.net/npm/vue"></script>
<script type="text/javascript">

function readGPX(file, callback) {

    function pointsDistance(p1, p2) {

        function _degreesToRadians(degrees) {
            return degrees * Math.PI / 180;
        }

        const EARTH_RADIUS_KM = 6371.009;
        let _p1 = { lat : _degreesToRadians(p1.lat), lon : _degreesToRadians(p1.lon) }
        let _p2 = { lat : _degreesToRadians(p2.lat), lon : _degreesToRadians(p2.lon) }

        let latDiff = _p1.lat - _p2.lat;
        let lonDiff = _p1.lon - _p2.lon;

        let a = Math.sin(latDiff / 2) * Math.sin(latDiff / 2)
            + Math.sin(lonDiff / 2) * Math.sin(lonDiff / 2)
            * Math.cos(_p1.lat) * Math.cos(_p2.lat);

        let radAngDist = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        let distanceKm = EARTH_RADIUS_KM * radAngDist;
        return distanceKm;
    }

    function gpxToJSON(trkpts) {

        let trackpoints = [];
        for( let trkpt = 0; trkpt < trkpts.length; trkpt++ ){

            let point = trkpts[ trkpt ];
            let lon = parseFloat( point.getAttribute('lon') );
            let lat = parseFloat( point.getAttribute('lat') );
            let elevation = point.getElementsByTagName('ele')[0].textContent;
            let time = point.getElementsByTagName('time')[0].textContent;

            trackpoints.push({ lon, lat, elevation, time });
        }
        return trackpoints;
    }

    function averageElevation(trkpts) {
        let elevation = 0;
        let devideBy = 0;

        for (let trkpt = 0; trkpt < trkpts.length; trkpt++ ){
            let point = trkpts[trkpt];
            if ( point.querySelector('ele') ) {
                elevation += parseFloat( point.querySelector( 'ele' ).textContent );
                devideBy++;
            }
        }
        return elevation / devideBy;
    }

    function msToTime(ms) {

        let seconds = parseInt( ( ms / 1000 ) % 60, 10 );
        let minutes = parseInt( ( ms / ( 1000 * 60 ) ) % 60, 10 );
        let hours = parseInt( ( ms / ( 1000 * 60 * 60 ) ) % 24, 10 );
        let days = parseInt( ms / ( 1000 * 60 * 60 * 24 ), 10 );
        let hoursDays = parseInt( days * 24, 10 );
            hours += hoursDays;

        return {
            hours : String(hours).padStart(2, '0'),
            minutes : String(minutes).padStart(2, '0'),
            seconds : String(seconds).padStart(2, '0'),
            ms : ms
        }
    }

    function GPX(gpxData) {
        let _xmlDoc = new DOMParser().parseFromString(gpxData, 'application/xml');
        let _trkpts = [];
            try { _trkpts = _xmlDoc.querySelectorAll( 'trkpt' ) }
            catch(e) { _trkpts = _xmlDoc.documentElement.getElementsByTagName( 'trkpt' ) }

        const trackpoints = gpxToJSON(_trkpts);

        const start = new Date( trackpoints[ 0 ].time );
        const end = new Date( trackpoints[ trackpoints.length - 1 ].time );
        const duration = msToTime( Math.abs(end.getTime() - start.getTime()) );
        const distance = (function() {

            let _distance = 0;
            for( let i = 0; i < trackpoints.length - 1; i++ ){
                _distance += pointsDistance( trackpoints[i], trackpoints[i+1] );
            }
            return {
                km : _distance,
                mi : _distance * 0.621371
            };

        }());

        const pace = (function() {

            let _msKm = duration.ms / distance.km;
            let _msMi = duration.ms / distance.mi;
            return {
                'perKm' : {
                    'minutes' : String(new Date( _msKm ).getUTCMinutes()).padStart(2, '0'),
                    'seconds' : String(new Date( _msKm ).getUTCSeconds()).padStart(2, '0')
                },
                'perMile' : {
                    'minutes' : String(new Date( _msMi ).getUTCMinutes()).padStart(2, '0'),
                    'seconds' : String(new Date( _msMi ).getUTCSeconds()).padStart(2, '0')
                }
            }

        }());

        const speed = {
            'kmh' : (distance.km * 3600000) / duration.ms,
            'mih' : (distance.mi * 3600000) / duration.ms
        }

        const elevation = (function() {

            let eleForMinMax = [];
            // let richElevation = [];
            let gain = 0;
            let loss = 0;
            let startTime = new Date(trackpoints[0].time).getTime();
            // let dist = 0;

            for( let i = 0; i < trackpoints.length - 1; i++ ){
                let diff = trackpoints[i+1].elevation - trackpoints[i].elevation;
                let time = new Date( trackpoints[i+1].time ).getTime();
                let timeDiff = Math.abs( time - startTime );

                    // dist += pointsDistance(trackpoints[i], trackpoints[i+1]);

                if ( diff < 0 ) { loss += diff }
                if ( diff > 0 ) { gain += diff }

                eleForMinMax.push( trackpoints[i].elevation );
                // richElevation.push( {
                //     elevation: trackpoints[i].elevation,
                //     time: msToTime(timeDiff).ms,
                //     dist: dist }
                // );
            }

            return {
                // elevation: richElevation,
                max: Math.max.apply( null, eleForMinMax ),
                min: Math.min.apply( null, eleForMinMax ),
                loss: loss,
                gain: gain,
                // average : averageElevation(_trkpts)
            }

        }());

        // return {start, end, duration, distance, pace, speed};
        return { duration, distance, pace, speed, elevation };
    }

    let reader = new FileReader();
        reader.readAsText(file, 'UTF-8');
        reader.onload = function(e) {

            callback( GPX(this.result) );
        }
}




const Data = {
    gpx : {
        duration : { hours : 0, minutes : 0, seconds : 0, ms : 0 },
        distance : { km : 0, mi : 0 },
        pace : { perKm : { minutes : 0, seconds : 0 }, perMi : { minutes : 0, seconds : 0 }},
        speed : { kmh : 0, mih : 0 },
        elevation : { max : 0, min : 0, loss : 0, gain : 0 }
    },
    image : {}
}
const App = new Vue({

    el: '#app',
    data: Data,
    methods : {
        loadGPX : function(e) {
            // TODO : Validate file input
            readGPX(
                e.target.files[0],
                (gpxData) => { Data.gpx = gpxData }
            );
        }
    },

    created : function() {}

})

</script>

</body>
</html>
